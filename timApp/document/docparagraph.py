import json
import os
import shelve
from collections import defaultdict
from copy import copy
from typing import Optional, Dict, List, Tuple, Any

import commonmark
import filelock
from commonmark.node import Node
from jinja2.sandbox import SandboxedEnvironment

from timApp.document.documentparser import DocumentParser
from timApp.document.documentparseroptions import DocumentParserOptions
from timApp.document.documentwriter import DocumentWriter
from timApp.document.macroinfo import MacroInfo
from timApp.document.preloadoption import PreloadOption
from timApp.document.randutils import random_id, hashfunc
from timApp.markdown.dumboclient import DumboOptions, MathType, InputFormat
from timApp.markdown.htmlSanitize import sanitize_html, strip_div
from timApp.markdown.markdownconverter import par_list_to_html_list, expand_macros, format_heading
from timApp.timdb.exceptions import TimDbException, InvalidReferenceException
from timApp.timtypes import DocumentType
from timApp.util.rndutils import get_rands_as_dict, get_rands_as_str, SeedType
from timApp.util.utils import count_chars_from_beginning, get_error_html, title_to_id

SKIPPED_ATTRS = {'r', 'rd', 'rp', 'ra', 'rt', 'settings'}


se = SandboxedEnvironment(autoescape=True)


class DocParagraph:
    """Represents a paragraph that is associated with a :class:`Document`. See :doc:`docparagraph` for more info.
    """

    def __init__(self, doc):
        """Constructs a DocParagraph.

        :param doc: The Document object to which this paragraph is connected.
        """
        self.doc: DocumentType = doc
        self.prev_deref: Optional['DocParagraph'] = None
        self.ref_doc = None
        self.original = None
        self.html_sanitized = False
        self.html = None
        self.final_dict = None
        self.style = None # style for min/max-height ans autoscroll

        # Cache for referenced paragraphs. Keys {True, False} correspond to the values of set_html parameter in
        # get_referenced_pars.
        self.ref_pars = {}
        self.__rands = None   # random number macros for this pg
        self.__rnd_seed = 0
        self.attrs = None
        self.nomacros = False
        self.nocache = False
        self.ref_chain = None

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.is_identical_to(other)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not (self == other)
        return NotImplemented

    def __hash__(self):
        return hash(tuple(sorted(self.__dict__.items())))

    @staticmethod
    def help_par():
        """Returns a dummy paragraph with id 'HELP_PAR' that is used as a placeholder for an empty document."""
        return DocParagraph.create(doc=None, par_id='HELP_PAR')

    @classmethod
    def create(cls,
               doc,
               par_id: Optional[str] = None,
               md: str = '',
               par_hash: Optional[str] = None,
               html: Optional[str] = None,
               attrs: Optional[Dict] = None) -> 'DocParagraph':
        """Creates a DocParagraph from the given parameters.

        :param doc: The Document object to which this paragraph is connected.
        :param par_id: The paragraph id or None if it should be autogenerated.
        :param md: The markdown content.
        :param par_hash: The hash for the paragraph or None if it should be computed.
        :param html: The HTML for the paragraph or None if it should be generated based on markdown.
        :param attrs: The attributes for the paragraph.
        :return: The created DocParagraph.

        """
        par = DocParagraph(doc)
        par.html = html
        par.__data = {
            'id': random_id() if par_id is None else par_id,
            'md': md,
            't': hashfunc(md, attrs) if par_hash is None else par_hash,
            'attrs': {} if attrs is None else attrs
        }
        par.attrs = par.__data['attrs']
        par.nomacros = None  # par.no_macros()  # par.attrs.get('nomacros', False)
        par.nocache = par.attrs.get('nocache', False)
        par._cache_props()
        return par

    def create_reference(self, doc, r: Optional[str] = None, add_rd: bool = True) -> 'DocParagraph':
        """Creates a reference paragraph to this paragraph.

        :param doc: The Document object in which the reference paragraph will reside.
        :param r: The kind of the reference.
        :param add_rd: If True, sets the rd attribute for the reference paragraph.
        :return: The created DocParagraph.

        """
        return create_reference(doc, doc_id=self.get_doc_id(), par_id=self.get_id(), r=r, add_rd=add_rd)

    @staticmethod
    def create_area_reference(doc, area_name: str, r: Optional[str] = None, rd: Optional[int] = None) -> 'DocParagraph':
        """Creates an area reference paragraph.

        :param area_name: The name of the area.
        :param doc: The Document object in which the reference paragraph will reside.
        :param r: The kind of the reference.
        :param add_rd: If True, sets the rd attribute for the reference paragraph.
        :return: The created DocParagraph.

        """
        par = DocParagraph.create(doc)
        par.set_attr('r', r)
        par.set_attr('rd', doc.doc_id if rd is None else rd)
        par.set_attr('ra', area_name)
        par.set_attr('rp', None)

        par._cache_props()
        return par

    @classmethod
    def from_dict(cls, doc, d: Dict) -> 'DocParagraph':
        """Creates a paragraph from a dictionary.

        :param doc: The Document object in which the paragraph will reside.
        :param d: The dictionary.
        :return: The created DocParagraph.

        """
        par = DocParagraph(doc)
        par.__data = dict(d)
        if 'attrs' not in par.__data:
            par.__data['attrs'] = {}
        par.attrs = par.__data['attrs']
        par.nomacros = None  # par.no_macros()  # par.attrs.get('nomacros', False)
        par.nocache = par.attrs.get('nocache', False)
        par._cache_props()
        par._compute_hash()
        return par

    def no_macros(self):
        nm =  self.attrs.get('nomacros', None)
        if nm is not None:
            nm = nm.lower()
            return nm != 'false'
        return self.doc.get_settings().nomacros(False)

    @staticmethod
    def is_no_macros(settings, doc_macros):
        nm = settings.get('nomacros')
        if nm is not None:
            nm = nm.lower()
            return nm != 'false'
        return doc_macros

    @classmethod
    def get_latest(cls, doc, par_id: str) -> 'DocParagraph':
        """Retrieves the latest paragraph version from the data store.

        :param doc: The Document object for which to retrieve the paragraph.
        :param par_id: The paragraph id.
        :return: The retrieved DocParagraph.

        """
        try:
            t = os.readlink(cls._get_path(doc, par_id, 'current'))
            return cls.get(doc, par_id, t)
        except FileNotFoundError:
            doc._raise_not_found(par_id)

    @classmethod
    def get(cls, doc, par_id: str, t: str) -> 'DocParagraph':
        """Retrieves a specific paragraph version from the data store.

        :param doc: The Document object for which to retrieve the paragraph.
        :param par_id: The paragraph id.
        :param t: The paragraph hash.
        :return: The retrieved DocParagraph.

        """
        try:
            with open(cls._get_path(doc, par_id, t), 'r') as f:
                return cls.from_dict(doc, json.loads(f.read()))
        except FileNotFoundError:
            doc._raise_not_found(par_id)

    def __iter__(self):
        """Returns an iterator to the internal data dictionary."""
        return self.__data.__iter__()

    @classmethod
    def _get_path(cls, doc, par_id: str, t: str) -> str:
        """Returns the filesystem location for a specific paragraph version.

        :param doc: The Document object in which the paragraph resides.
        :param par_id: The paragraph id.
        :param t: The paragraph hash.
        :return: The filesystem location for the paragraph.

        """
        from timApp.timdb.dbaccess import get_files_path
        froot = get_files_path()
        return (froot / 'pars' / str(doc.doc_id) / par_id / t).as_posix()

    @classmethod
    def _get_base_path(cls, doc, par_id: str) -> str:
        """Returns the filesystem location for the versions of a given paragraph.

        :param doc: The Document object in which the paragraph resides.
        :param par_id: The paragraph id.
        :return: The filesystem location for the versions of the paragraph.

        """
        from timApp.timdb.dbaccess import get_files_path
        froot = get_files_path()
        return (froot / 'pars' / str(doc.doc_id) / par_id).as_posix()

    def dict(self) -> Dict:
        """Returns the internal data dictionary."""
        return self.__data

    def _make_final_dict(self, from_preview: bool = True, output_md: bool = False):
        """Prepares the internal __htmldata dictionary that contains all the information required for embedding the
        paragraph in HTML."""
        self._cache_props()

        if self.original:
            self.final_dict = dict(self.original.__data)
            self.final_dict['attrs_str'] = self.original.get_attrs_str()
            self.final_dict['doc_id'] = self.original.doc.doc_id

            self.final_dict['ref_doc_id'] = self.ref_doc.doc_id
            self.final_dict['ref_id'] = self.__data['id']
            self.final_dict['ref_t'] = self.__data['t']
            self.final_dict['ref_attrs'] = self.__data['attrs']
            self.final_dict['ref_attrs_str'] = self.get_attrs_str()
        else:
            self.final_dict = dict(self.__data)
            self.final_dict['attrs_str'] = self.get_attrs_str()
            self.final_dict['doc_id'] = self.doc.doc_id

        if output_md:
            self.final_dict['md'] = self.get_markdown()
        else:
            try:
                self.final_dict['html'] = self.get_html(from_preview=from_preview)

            except Exception as e:
                self.final_dict['html'] = get_error_html(e)

        preamble = self.from_preamble()
        plugintype = self.get_attr('plugin')
        self.final_dict['cls'] = ' '.join(['par']
                                          + (self.get_classes() if not self.get_attr('area') else [])
                                          + (['questionPar'] if self.is_question() else [])
                                          + (['preamble'] if preamble else [])
                                          + ([plugintype] if self.is_plugin() and not self.is_question() else [])
                                          )
        # Need to check for gamification attribute to avoid ng-non-bindable directive being added in the par.
        # As an AngularJS component it needs to be processed by AngularJS. is_plugin also shouldn't return True
        # for gamification because it isn't a proper plugin.
        self.final_dict['is_plugin'] = self.is_plugin() or self.has_plugins() or self.get_attr('gamification') is not None
        if preamble:
            self.final_dict['from_preamble'] = preamble.path
        self.final_dict['is_question'] = self.is_question()
        self.final_dict['is_setting'] = self.is_setting()
        self.final_dict['style'] = None

    def _cache_props(self):
        """Caches some boolean properties about this paragraph in internal attributes."""

        self.__is_ref = self.is_par_reference() or self.is_area_reference()
        self.__is_setting = 'settings' in self.get_attrs()

    def get_final_dict(self, use_md: bool = False) -> Dict:
        """Returns a dictionary that contains the finalized values of the paragraph."""
        if self.final_dict:
            return self.final_dict
        self._make_final_dict(output_md=use_md)
        return self.final_dict

    def get_doc_id(self) -> int:
        """Returns the Document id to which this paragraph is attached."""
        return self.doc.doc_id

    def get_id(self) -> str:
        """Returns the id of this paragraph."""
        return self.__data['id']

    def get_rd(self) -> Optional[int]:
        """Returns the id of the Document to which this paragraph refers, or None if this is not a reference
        paragraph."""
        try:
            rd = self.get_attr('rd')
            return None if rd is None else int(rd)
        except ValueError:
            return None

    def is_identical_to(self, par: 'DocParagraph'):
        return self.is_same_as(par) and self.get_id() == par.get_id()

    def is_different_from(self, par: 'DocParagraph') -> bool:
        """Determines whether the given paragraph is different from this paragraph content-wise."""
        return not self.is_same_as(par)

    def is_same_as(self, par: 'DocParagraph') -> bool:
        """Determines whether the given paragraph is same as this paragraph content-wise."""
        return self.get_hash() == par.get_hash() and self.get_attrs() == par.get_attrs()

    def is_same_as_html(self, par: 'DocParagraph'):
        return self.is_same_as(par) and self.get_html(from_preview=True) == par.get_html(from_preview=True)

    def get_hash(self) -> str:
        """Returns the hash of this paragraph."""
        return self.__data['t']

    def get_markdown(self) -> str:
        """Returns the markdown of this paragraph."""
        return self.__data['md']

    def get_rands_str(self, rnd_seed: Optional[SeedType]) -> str:
        ret, self.__rnd_seed = get_rands_as_str(self.attrs, rnd_seed, None)
        return ret

    def insert_before_md(self, s: str):
        """ Insert s before md text.  s may need to contain \n """
        md = self.__data['md']
        if md.startswith('```\n'):
            self.__data['md'] = '```\n' + s + md[4:]
        else:
            self.__data['md'] = s + self.__data['md']

    def insert_rnds(self, rnd_seed: Optional[SeedType]) ->bool:
        """ Inserts Jinja rnd variable as a list of random numbers based to attribute rnd and rnd_seed
            return True if attribute rnd found and OK, else False
        """
        self.__rands, self.__rnd_seed, state = get_rands_as_dict(self.attrs, rnd_seed, None)
        if self.__rands is None:
            return False
        return True

    def get_rands(self):
        return self.__rands

    def get_nomacros(self):
        if self.nomacros is not None:
            return self.nomacros
        self.nomacros = self.no_macros()
        return self.nomacros

    def get_nocache(self):
        return self.nocache

    def get_expanded_markdown(self, macroinfo: Optional[MacroInfo]=None,
                              ignore_errors: bool = False) -> str:
        """Returns the macro-processed markdown for this paragraph.

        :param macroinfo: The MacroInfo to use. If None, the MacroInfo is taken from the document that has the
        paragraph.
        :param ignore_errors: Whether or not to ignore errors when expanding the macros
        :return: The expanded markdown.

        """
        md = self.get_markdown()
        if self.get_nomacros():
            return md
        settings = self.doc.get_settings()
        if macroinfo is None:
            macroinfo = settings.get_macroinfo()
        macros = macroinfo.get_macros(nocache=self.get_nocache())

        if self.insert_rnds(md + macros.get("username", "")):  # TODO: RND_SEED: check what seed should be used, is this used to plugins?
            macros = {**macros, **self.__rands}
        return expand_macros(md, macros, settings, macroinfo.get_macro_delimiter(), ignore_errors=ignore_errors)

    def get_title(self) -> Optional[str]:
        """Attempts heuristically to return a title for this paragraph.

        :return: The title for this paragraph or None if there is no sensible title.

        """
        md = self.__data['md']
        if len(md) < 3 or md[0] != '#' or md[1] == '-':
            return None

        attr_index = md.find('{')
        return md[2:attr_index].strip() if attr_index > 0 else md[2:].strip()

    def get_exported_markdown(self, skip_tr=False, export_ids=False) -> str:
        """Returns the markdown in exported form for this paragraph."""
        if (not skip_tr) and self.is_par_reference() and self.is_translation():
            # This gives a default translation based on the source paragraph
            # todo: same for area reference
            data = []
            try:
                ref_pars = self.get_referenced_pars(set_html=False)
            except InvalidReferenceException:
                pass
            else:
                for par in ref_pars:
                    d = self.__data.copy()  # todo: needs copy or not?
                    md = par.get_markdown()
                    if md:
                        d['md'] = md
                    data.append(d)
                return DocumentWriter(data, export_hashes=False, export_ids=export_ids).get_text()
        return DocumentWriter([self.__data],
                              export_hashes=False,
                              export_ids=export_ids).get_text(DocumentParserOptions.single_paragraph())

    def __get_setting_html(self) -> str:
        """Returns the HTML for the settings paragraph."""
        from timApp.document.docsettings import DocSettings

        try:
            DocSettings.from_paragraph(self)
        except TimDbException as e:
            return f'<div class="pluginError">Invalid settings: {e}</div>'
        return se.from_string('<pre>{{yml}}</pre>').render(yml=self.get_markdown())

    def get_html(self, from_preview: bool = True) -> str:
        """Returns the html for the paragraph.

        :param from_preview: Whether this is called from a preview window or not.
                             If True, previous paragraphs are preloaded too and the result is not cached.
                             Safer, but slower. Set explicitly False if you know what you're doing.
        :return: html string

        """
        if self.html is not None:
            return self.html
        if self.is_plugin() or self.has_plugins():
            return self._set_html('')
        if self.is_setting():
            return self._set_html(self.__get_setting_html())

        context_par = self.doc.get_previous_par(self, get_last_if_no_prev=False) if from_preview else None

        preload_pars = self.doc.get_paragraphs() if self.doc.preload_option == PreloadOption.all else [self]
        DocParagraph.preload_htmls(preload_pars,
                                   self.doc.get_settings(),
                                   context_par=context_par,
                                   persist=not from_preview)

        # This DocParagraph instance is not necessarily the same as what self.doc contains. In that case, we copy the
        # HTML from the doc's equivalent paragraph.
        if self.html is None:
            self.html = self.doc.par_map[self.get_id()]['c'].html
            assert self.html is not None
        return self.html

    @classmethod
    def preload_htmls(cls, pars: List['DocParagraph'], settings,
                      clear_cache: bool = False, context_par: Optional['DocParagraph'] = None,
                      persist: Optional[bool] = True):
        """Loads the HTML for each paragraph in the given list.

        :param context_par: The context paragraph. Required only for previewing for now.
        :param persist: Whether the result of preloading should be saved to disk.
        :param clear_cache: Whether all caches should be refreshed.
        :param settings: The document settings.
        :param pars: Paragraphs to preload.
        :return: A list of paragraphs whose HTML changed as the result of preloading.

        """
        if not pars:
            return []

        doc_id = pars[0].doc.doc_id
        macro_cache_file = f'/tmp/tim_auto_macros_{doc_id}'
        heading_cache_file = f'/tmp/heading_cache_{doc_id}'

        first_pars = []
        if context_par is not None:
            first_pars = [context_par]
            pars = first_pars + pars

        if not persist:
            cache = {}
            heading_cache = {}
            with shelve.open(macro_cache_file) as c, \
                    shelve.open(heading_cache_file) as hc:

                # Basically we want the cache objects to be non-persistent, so we convert them to normal dicts
                # Find out better way if possible...
                for par in first_pars:
                    key = str((par.get_id(), par.doc.get_version()))
                    value = c.get(key)
                    if value is not None:
                        cache[key] = value
                    value = hc.get(par.get_id())
                    if value is not None:
                        heading_cache[par.get_id()] = value
            unloaded_pars = cls.get_unloaded_pars(pars, settings, cache, heading_cache, clear_cache)
        else:
            with filelock.FileLock(f"/tmp/cache_lock_{doc_id}"):
                if clear_cache:
                    try:
                        os.remove(macro_cache_file + '.db')
                    except FileNotFoundError:
                        pass
                    try:
                        os.remove(heading_cache_file + '.db')
                    except FileNotFoundError:
                        pass
                with shelve.open(macro_cache_file) as cache, \
                        shelve.open(heading_cache_file) as heading_cache:
                    unloaded_pars = cls.get_unloaded_pars(pars, settings, cache, heading_cache, clear_cache)
                    for k, v in heading_cache.items():
                        heading_cache[k] = v

        changed_pars = []
        if len(unloaded_pars) > 0:
            def deref_tr_par(p):
                """Required for getting the original par's attributes, so that for example "nonumber" class
                doesn't have to be repeated in translations.
                """
                if not p.is_translation():
                    return p
                try:
                    return p.get_referenced_pars(set_html=False)[0]
                except InvalidReferenceException as e:
                    p.was_invalid = True
                    p._set_html(get_error_html(e))
                    return p
            htmls = par_list_to_html_list([deref_tr_par(par) for par, _, _, _, _ in unloaded_pars],
                                          auto_macros=({'h': auto_macros['h'], 'headings': hs}
                                                       for _, _, auto_macros, hs, _ in unloaded_pars),
                                          settings=settings)
            for (par, auto_macro_hash, _, _, old_html), h in zip(unloaded_pars, htmls):
                # h is not sanitized but old_html is, but HTML stays unchanged after sanitization most of the time
                # so they are comparable after stripping div. We want to avoid calling sanitize_html unnecessarily.
                if getattr(par, 'was_invalid', False):
                    continue
                if isinstance(h, bytes):
                    h = h.decode()
                h = strip_div(h)
                if h != old_html:
                    h = sanitize_html(h)
                    if not par.from_preamble():
                        changed_pars.append(par)
                par.__data['h'][auto_macro_hash] = h
                par._set_html(h, sanitized=True)
                if persist and not par.from_preamble():
                    par.__write()
        return changed_pars

    @classmethod
    def get_unloaded_pars(cls, pars, settings, auto_macro_cache, heading_cache, clear_cache=False):
        """Finds out which of the given paragraphs need to be preloaded again.

        :param pars: The list of paragraphs to be processed.
        :param settings: The settings for the document.
        :param auto_macro_cache: The cache object from which to retrieve and store the auto macro data.
        :param heading_cache: A cache object to store headings into. The key is paragraph id and value is a list of headings
         in that paragraph.
        :param clear_cache: Whether all caches should be refreshed.
        :return: A 5-tuple of the form:
          (paragraph, hash of the auto macro values, auto macros, so far used headings, old HTML).

        """
        cumulative_headings = []
        unloaded_pars = []
        dyn = 0
        l = 0
        macroinfo = settings.get_macroinfo()
        macros = macroinfo.get_macros()
        macro_delim = macroinfo.get_macro_delimiter()
        settings_hash = settings.get_hash()
        for par in pars:
            if par.is_dynamic():
                dyn += 1
                continue
            if not clear_cache and par.html is not None:
                continue
            cached = par.__data.get('h')
            try:
                auto_number_start = settings.auto_number_start()
                auto_macros = par.get_auto_macro_values(macros, macro_delim, auto_macro_cache, heading_cache,
                                                        auto_number_start)
            except RecursionError:
                raise TimDbException(
                    'Infinite recursion detected in get_auto_macro_values; the document may be broken.')
            auto_macro_hash = hashfunc(settings_hash + str(auto_macros))

            par_headings = heading_cache.get(par.get_id())
            if cumulative_headings:
                # Performance optimization: copy only if the set of headings changes
                if par_headings:
                    all_headings_so_far = cumulative_headings[-1].copy()
                else:
                    all_headings_so_far = cumulative_headings[-1]
            else:
                all_headings_so_far = defaultdict(int)
            cumulative_headings.append(all_headings_so_far)
            if par_headings is not None:
                for h in par_headings:
                    all_headings_so_far[h] += 1

            if not clear_cache and cached is not None:
                if type(cached) is str:  # Compatibility
                    old_html = cached
                else:
                    cached_html = cached.get(auto_macro_hash)
                    if cached_html is not None:
                        par.html = cached_html
                        l += 1
                        continue
                    else:
                        try:
                            old_html = next(iter(cached.values()))
                        except StopIteration:
                            old_html = None
            else:
                old_html = None

            tup = (par, auto_macro_hash, auto_macros, all_headings_so_far, old_html)
            par.__data['h'] = {}
            unloaded_pars.append(tup)
        return unloaded_pars

    def has_class(self, class_name):
        """Returns whether this paragraph has the specified class."""
        return class_name in self.get_classes()

    def add_class(self, *classes: str):
        """Adds the specified class to this paragraph."""
        for class_name in classes:
            if not self.has_class(class_name):
                curr_classes = self.get_classes()
                curr_classes.append(class_name)
                self.set_attr('classes', curr_classes)

    def get_auto_macro_values(self, macros, macro_delim, auto_macro_cache, heading_cache, auto_number_start):
        """Returns the auto macros values for the current paragraph. Auto macros include things like current
        heading/table/figure numbers.

        :param heading_cache: A cache object to store headings into. The key is paragraph id and value is a list of headings
         in that paragraph.
        :param macros: Macros to apply for the paragraph.
        :param auto_macro_cache: The cache object from which to retrieve and store the auto macro data.
        :param auto_number_start: first heading start number
        :return: Auto macro values as a dict.
        :param macro_delim: Delimiter for macros.
        :return: A dict(str, dict(int,int)) containing the auto macro information.

        """

        key = str((self.get_id(), self.doc.get_version()))
        cached = auto_macro_cache.get(key)
        if cached is not None:
            return cached

        prev_par: 'DocParagraph' = self.doc.get_previous_par(self)
        if prev_par is None:
            autonumber_start = auto_number_start
            prev_par_auto_values = {'h': {1: autonumber_start, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}}
            heading_cache[self.get_id()] = []
        else:
            prev_par_auto_values = prev_par.get_auto_macro_values(macros, macro_delim, auto_macro_cache, heading_cache,
                                                                  auto_number_start)

        # If the paragraph is a translation but it has not been translated (empty markdown), we use the md from the original.
        deref = None
        if prev_par is not None and prev_par.is_translation():
            try:
                deref = prev_par.get_referenced_pars(set_html=False)[0]
            except InvalidReferenceException:
                # In case of an invalid reference, just skip this one.
                deref = None
        if prev_par is None or prev_par.is_dynamic() or prev_par.has_class('nonumber') or (deref and deref.has_class('nonumber')):
            auto_macro_cache[key] = prev_par_auto_values
            heading_cache[self.get_id()] = []
            return prev_par_auto_values

        md_expanded = prev_par.get_markdown()
        if not md_expanded and deref is not None:
            md_expanded = deref.get_markdown()
        if not prev_par.get_nomacros():
            # TODO: RND_SEED should we fill the rands also?
            md_expanded = expand_macros(md_expanded, macros, self.doc.get_settings(), macro_delim)
        blocks = DocumentParser(md_expanded, options=DocumentParserOptions.break_on_empty_lines()).get_blocks()
        deltas = copy(prev_par_auto_values['h'])
        title_ids = []
        for e in blocks:
            level = count_chars_from_beginning(e['md'], '#')
            if 0 < level < 7:
                title = e['md'][level:].strip()
                title_ids.append(title_to_id(title))
                deltas[level] += 1
                for i in range(level + 1, 7):
                    deltas[i] = 0
        heading_cache[self.get_id()] = title_ids
        result = {'h': deltas}
        auto_macro_cache[key] = result
        return result

    def sanitize_html(self):
        """Sanitizes the HTML for this paragraph.

        If the HTML has already been sanitized or the HTML has not been loaded, this method does nothing.

        """
        if self.html_sanitized or not self.html:
            return
        new_html = sanitize_html(self.html)
        self._set_html(new_html, True)

    def _set_html(self, new_html: str, sanitized: bool = False) -> str:
        """Sets the HTML for this paragraph.

        :param new_html: The new HTML.
        :param sanitized: Whether the HTML is sanitized. Default is False.
        :return: The HTML.

        """
        self.html = new_html
        if self.final_dict is not None:
            self.final_dict['html'] = new_html
        self.html_sanitized = sanitized
        return self.html

    def get_attr(self, attr_name: str, default_value=None):
        """Returns the value of the specified attribute.

        :param attr_name: The name of the attribute to get.
        :param default_value: The default value to return if the attribute does not exist.
        :return: The attribute value.

        """
        return self.attrs.get(attr_name, default_value)

    def set_markdown_temp(self, new_md: str):
        """Sets markdown for this paragraph.

        :param new_md: The new markdown.

        """
        self.__data['md'] = new_md

    def set_markdown(self, new_md: str):
        """Sets markdown for this paragraph.

        :param new_md: The new markdown.

        """
        self.__data['md'] = new_md
        self._compute_hash()

    def _compute_hash(self):
        self.__data['t'] = hashfunc(self.get_markdown(), self.get_attrs())

    def set_attr(self, attr_name: str, attr_val: Any):
        """Sets the value of the specified attribute.

        :param attr_name: The name of the attribute to set.
        :param attr_val: The value for the attribute.

        """
        if attr_val is None:
            self.attrs.pop(attr_name, None)
        else:
            self.attrs[attr_name] = attr_val

        self._cache_props()
        self._compute_hash()

    def is_task(self):
        """Returns whether the paragraph is a task."""
        return self.get_attr('taskId') is not None and self.get_attr('plugin') is not None

    @classmethod
    def __combine_dict(cls, base_dict: Optional[Dict], over_dict: Dict) -> Dict:
        """Merges two Dicts together."""
        if base_dict is None:
            return over_dict
        new_dict = dict(base_dict)
        for key in over_dict:
            new_dict[key] = over_dict[key]
        return new_dict

    def get_attrs(self) -> Dict:
        return self.attrs

    def get_attrs_str(self) -> str:
        """Returns the attributes as a JSON string."""
        return json.dumps(self.attrs, sort_keys=True)

    def get_classes(self) -> List[str]:
        return self.get_attr('classes', [])

    def get_class_str(self) -> str:
        """Returns the classes as a space-separated string."""
        return ' '.join(self.get_classes())

    def get_base_path(self) -> str:
        """Returns the filesystem path for the versions of this paragraph."""
        return self._get_base_path(self.doc, self.get_id())

    def get_path(self) -> str:
        """Returns the filesystem path for this paragraph."""
        return self._get_path(self.doc, self.__data['id'], self.__data['t'])

    def __read(self) -> bool:
        if not os.path.isfile(self.get_path()):
            return False
        with open(self.get_path(), 'r') as f:
            self.__data = json.loads(f.read())
            self._cache_props()
            self.final_dict = None
            return True

    def __write(self):
        file_name = self.get_path()
        does_exist = os.path.isfile(file_name)

        if not does_exist:
            base_path = self.get_base_path()
            if not os.path.exists(base_path):
                os.makedirs(base_path)

        with open(file_name, 'w') as f:
            f.write(json.dumps(self.__data))

    def set_latest(self):
        """Updates the 'current' symlink to point to this paragraph version."""
        linkpath = self._get_path(self.doc, self.get_id(), 'current')
        if linkpath == self.get_hash():
            return
        if os.path.islink(linkpath) or os.path.isfile(linkpath):
            os.unlink(linkpath)
        os.symlink(self.get_hash(), linkpath)

    def clone(self) -> 'DocParagraph':
        """Clones the paragraph.

        :return: The cloned paragraph.

        """
        p = self
        return DocParagraph.create(
            attrs=p.get_attrs(),
            doc=p.doc,
            html=p.html,
            md=p.get_markdown(),
            par_hash=p.get_hash(),
            par_id=p.get_id(),
        )

    def clear_cache(self):
        """Clears the HTML cache of this paragraph."""
        self.__data.pop('h', None)

    def save(self, add=False):
        """Performs a save operation for this paragraph.

        This updates the document version and paragraph list appropriately.

        :param add: Whether to add (True) or modify an existing (False).

        """
        # TODO: Possibly get rid of 'add' parameter altogether.
        if add:
            self.doc.add_paragraph_obj(self)
        else:
            self.doc.modify_paragraph_obj(self.get_id(), self)

    def store(self):
        """Stores the paragraph to disk."""
        self.__write()

        # Clear cached referenced paragraphs because this was modified
        self.ref_pars = {}

    def is_reference(self) -> bool:
        """Returns whether this paragraph is a reference to some other paragraph."""
        return self.__is_ref

    def is_par_reference(self) -> bool:
        """Returns whether this paragraph is a reference to a single paragraph."""
        return self.get_attr('rp') is not None

    def is_area_reference(self) -> bool:
        """Returns whether this paragraph is a reference to an area."""
        return self.get_attr('ra') is not None

    def is_translation(self) -> bool:
        """Returns whether this paragraph is a translated paragraph."""
        return self.get_attr('r') == 'tr' and self.get_attr('rp') is not None

    def __repr__(self):
        return self.__data.__repr__()

    def get_referenced_pars(self, set_html: bool = True) -> List['DocParagraph']:
        cached = self.ref_pars.get(set_html)
        if cached is not None:
            return cached
        pars = [create_final_par(p, set_html=set_html) for p in self.get_referenced_pars_impl()]
        self.ref_pars[set_html] = pars
        return pars

    def get_referenced_pars_impl(self, visited_pars: Optional[List[Tuple[int, str]]] = None) -> List['DocParagraph']:
        """Returns the paragraphs that are referenced by this paragraph.

        The references are resolved recursively, i.e. if the referenced paragraphs are references themselves, they
        will also be resolved, and so on, until we get a list of non-reference paragraphs.

        :param visited_pars: A list of already visited paragraphs to prevent infinite recursion.
        :return: The list of resolved paragraphs.

        """
        if visited_pars is None:
            visited_pars = []
        par_doc_id = self.get_doc_id(), self.get_id()
        if par_doc_id in visited_pars:
            visited_pars.append(par_doc_id)
            raise InvalidReferenceException(
                f'Infinite referencing loop detected: {" -> ".join((f"{d}:{p}" for d, p in visited_pars))}')
        visited_pars.append(par_doc_id)

        ref_docid = None
        ref_doc = None

        attrs = self.get_attrs()
        if 'rd' in attrs:
            try:
                ref_docid = int(attrs['rd'])
            except ValueError:
                raise InvalidReferenceException(f'Invalid reference document id: "{attrs["rd"]}"')
        else:
            ref_doc = self.doc.get_source_document() if not self.from_preamble() else self.from_preamble().document.get_source_document()

        if ref_doc is None:
            if ref_docid is None:
                raise InvalidReferenceException('Source document for reference not specified.')
            ref_doc = self.doc.get_ref_doc(ref_docid)

        if not ref_doc.exists():
            raise InvalidReferenceException('The referenced document does not exist.')

        if self.is_par_reference():
            try:
                par = ref_doc.get_paragraph(attrs['rp'])
                par.prev_deref = self
            except TimDbException:
                raise InvalidReferenceException('The referenced paragraph does not exist.')

            if par.is_reference():
                ref_pars = par.get_referenced_pars_impl(visited_pars=visited_pars)
            else:
                ref_pars = [par]
        elif self.is_area_reference():
            if self.is_translation():
                raise InvalidReferenceException("A translated paragraph cannot be an area reference.")
            section_pars = ref_doc.get_named_section(attrs['ra'])
            ref_pars = []
            for p in section_pars:
                p.prev_deref = self
                if p.is_reference():
                    ref_pars.extend(p.get_referenced_pars_impl(visited_pars=visited_pars))
                else:
                    ref_pars.append(p)
        else:
            assert False
        return ref_pars

    def is_dynamic(self) -> bool:
        """Returns whether this paragraph is a dynamic paragraph.

        A dynamic paragraph is a paragraph which is either

        * a plugin,
        * a reference which is not a translation, or
        * a setting.

        """
        return self.is_plugin() \
            or self.has_plugins() \
            or (self.__is_ref and not self.is_translation()) \
            or self.__is_setting

    def is_plugin(self) -> bool:
        """Returns whether this paragraph is a plugin."""

        return bool(self.get_attr('plugin'))

    def has_plugins(self) -> bool:
        """Returns whether this paragraph has inline plugins."""
        return bool(self.get_attr('defaultplugin'))

    def is_yaml(self) -> bool:
        """Returns whether this paragraph is YAML markup."""
        return self.is_plugin() or self.is_setting()

    def is_question(self) -> bool:
        """Returns whether this paragraph is a question paragraph."""
        return self.is_plugin() and bool(self.get_attr('question'))

    def is_setting(self) -> bool:
        """Returns whether this paragraph is a settings paragraph."""
        return self.__is_setting

    def from_preamble(self) -> Optional['DocInfo']:
        """Returns the preamble document for this paragraph if the paragraph has been copied from a preamble."""
        return getattr(self, 'preamble_doc', None)

    def set_id(self, par_id: str):
        """Sets the id for this paragraph.

        :param par_id: The new id for the paragraph.

        """
        self.__data['id'] = par_id

    def set_style(self, style: str):
        """Sets the style for this paragraph.

        :param style: The new style for the paragraph.

        """
        self.final_dict['style'] = style

    def get_style(self) -> str:
        """Returns the style of this paragraph."""
        try:
            return self.final_dict['style']
        except:
            return ''


    def is_citation(self):
        return self.get_attr('r') == 'c'

    def is_area(self):
        return self.get_attr('area') is not None or self.get_attr('area_end') is not None

    def has_dumbo_options(self):
        return bool(self.get_attr('math_type') or self.get_attr('math_preamble') or self.get_attr('input_format'))

    def get_dumbo_options(self, base_opts: DumboOptions=DumboOptions.default()):
        return DumboOptions(
            math_type=MathType.from_string(self.get_attr('math_type') or base_opts.math_type),
            math_preamble=self.get_attr('math_preamble') or base_opts.math_preamble,
            input_format=InputFormat.from_string(self.get_attr('input_format')) or base_opts.input_format,
        )

    def is_translation_out_of_date(self):
        if not self.ref_chain:
            return False
        last_ref = self.ref_chain.prev_deref
        reached_par = self.ref_chain
        return (
                last_ref.is_translation()
                and not reached_par.is_setting()
                and reached_par.get_hash() != last_ref.get_attr('rt')
        )


def is_real_id(par_id: Optional[str]):
    """Returns whether the given paragraph id corresponds to some real paragraph
    instead of being None or a placeholder value ('HELP_PAR').
    
    :param par_id: The paragraph id.
    :return: True if the given paragraph id corresponds to some real paragraph, False otherwise.
    """
    return par_id is not None and par_id != 'HELP_PAR'


def create_reference(doc: DocumentType, doc_id: int, par_id: str, r: Optional[str] = None, add_rd: bool = True) -> 'DocParagraph':
    """Creates a reference paragraph to a paragraph.

    :param par_id: Id of the original paragraph.
    :param doc_id: Id of the original document.
    :param doc: The Document object in which the reference paragraph will reside.
    :param r: The kind of the reference.
    :param add_rd: If True, sets the rd attribute for the reference paragraph.
    :return: The created DocParagraph.

    """
    par = DocParagraph.create(doc)

    par.set_attr('r', r)
    par.set_attr('rd', doc_id if add_rd else None)
    par.set_attr('rp', par_id)
    par.set_attr('ra', None)

    par._cache_props()
    return par


def create_final_par(reached_par: DocParagraph, set_html: bool) -> DocParagraph:
    """Creates the finalized dereferenced paragraph based on a chain of references."""
    last_ref = reached_par.prev_deref
    if last_ref.is_translation() and last_ref.get_markdown():
        md = last_ref.get_markdown()
    else:
        md = reached_par.get_markdown()

    first_ref = reached_par
    is_any_norm_reference = False
    ref_list = []
    while True:
        ref_list.append(first_ref)
        if not first_ref.prev_deref:
            break
        first_ref = first_ref.prev_deref
        is_any_norm_reference = is_any_norm_reference or (first_ref.is_reference() and not first_ref.is_translation())

    new_attrs = {}
    for r in reversed(ref_list):
        for k, v in r.get_attrs().items():
            if k in SKIPPED_ATTRS:
                continue
            if isinstance(v, list):
                li = new_attrs.get(k)
                if not isinstance(li, list):
                    li = []
                    new_attrs[k] = li
                li += v
            else:
                new_attrs[k] = v
    if all(p.is_setting() for p in ref_list):
        new_attrs['settings'] = ''

    final_par = DocParagraph.create(
        attrs=new_attrs,
        doc=reached_par.doc,
        md=md,
        par_hash=reached_par.get_hash(),
        par_id=reached_par.get_id(),
    )
    # We need 2 different documents under final_par:
    #  1. what document to use for settings: "doc" attribute
    #  2. what document id to put in HTML's ref-doc-id (might not be same as settings): "ref_doc" attribute
    final_par.original = first_ref
    final_par.ref_doc = reached_par.doc
    final_par._cache_props()
    final_par.final_dict = None
    if first_ref.from_preamble():
        final_par.preamble_doc = first_ref.from_preamble()
        if first_ref.is_translation():
            final_par.doc = first_ref.doc
            if not is_any_norm_reference:
                final_par.ref_doc = first_ref.doc.get_source_document()
    elif last_ref.is_translation():
        final_par.doc = last_ref.doc
        final_par.ref_doc = last_ref.doc.get_source_document()

    final_par.ref_chain = reached_par

    if set_html:
        html = last_ref.get_html(from_preview=False) if last_ref.is_translation(
        ) else reached_par.get_html(from_preview=False)

        # if html is empty, use the source
        if html == '':
            html = reached_par.get_html(from_preview=False)
        final_par._set_html(html)
    return final_par


def add_heading_numbers(s: str, ctx: DocParagraph, heading_format):
    d = ctx.doc
    macro_cache_file = f'/tmp/tim_auto_macros_{ctx.doc.doc_id}'
    ps = commonmark.Parser()
    parsed = ps.parse(s)
    with shelve.open(macro_cache_file) as cache:
        vals = cache.get(str((ctx.get_id(), d.get_version())), {}).get('h')
    if not vals:
        return s
    lines = s.splitlines(keepends=False)
    curr: Node = parsed.first_child
    while curr:
        if curr.t == 'heading':
            level = curr.level
            line_idx = curr.sourcepos[0][0] - 1
            heading_line = lines[line_idx]
            heading_start = '#' * level

            # Pandoc's table syntax can conflict with CommonMark heading syntax, so we need an extra check.
            # This could be more accurate, but it's enough for now.
            if heading_line.startswith(heading_start + ' '):
                line = heading_line[level + 1:]
                if not line.endswith('{.unnumbered}'):
                    lines[line_idx] = heading_start + ' ' + format_heading(line, level, vals, heading_format)
        curr = curr.nxt
    return '\n'.join(lines)
